{
  "hash": "f8d23cc2ec77cb5a47fbeda279005da3",
  "result": {
    "engine": "knitr",
    "markdown": "---\neval: true\ncode-fold: false\nengine: knitr\n---\n\n\n\n\n\n\n\n\n\n\n# Data manipulation\n\nIn this chapter we will use some very useful `dplyr` functions to handle and manipulate data.\n\nYou can load the `dplyr` package directly, or load the entire tidy universe (`tidyverse`).\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# library(tidyverse)\nlibrary(dplyr)\n```\n:::\n\n\n\n\n\n\n\n\n\n\nUsing the same dataset as in [R basics](r-basics.html#manipulation) but with slightly differences[^data-manipulation-1].\n\n[^data-manipulation-1]: This dataset includes the number of trips with origin in each neighborhood, divided by mode of transport, and inter or intra municipal trips.\n\nWe will do the same operations but in a simplified way.\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRIPS = readRDS(\"data/TRIPSorigin.Rds\")\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\n::: callout-important\nNote that it is very important to understand the R basics, that's why we started from there, even if the following functions will provide the same results.\n:::\n\nYou don't need to know everything!\nAnd you don't need to know by heart.\nThe following functions are the ones you will probably use most of the time to handle data.\n\n::: {.callout-tip appearance=\"simple\"}\nThere are several ways to reach the same solution.\nHere we present only one of them.\n:::\n\n## Select variables\n\nHave a look at your dataset.\nYou can open using `View()`, look at the information at the \"Environment\" panel, or even print the same information using `glimpse()`\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(TRIPS)\n```\n:::\n\n\n\n\n\n\n\n\n\n\nWe will create a new dataset with *Origin*, *Walk,* *Bike* and *Total*.\nThis time we will use the `select()` function.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRIPS_new = select(TRIPS, Origin, Walk, Bike, Total) # the first argument is the dataset\n```\n:::\n\n\n\n\n\n\n\n\n\n\nThe first argument, as usually in R, is the dataset, and the remaining ones are the columns to select.\n\nWith most of the `dplyr` functions you don't need to refer to `data$...` you can simply type the variable names (and even without the `\"...\"`!).\nThis makes coding in R simpler :)\n\nYou can also remove columns that you don't need.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRIPS_new = select(TRIPS_new, -Total) # dropping the Total column\n```\n:::\n\n\n\n\n\n\n\n\n\n\n### Using pipes!\n\nNow, let's introduce pipes.\nPipes are a rule as: \"**With this, do this.**\"\n\nThis is useful to skip the first argument of the functions (usually the dataset to apply the function).\n\nApplying a pipe to the `select()` function, we can write as:\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRIPS_new = TRIPS |> select(Origin, Walk, Bike, Total)\n```\n:::\n\n\n\n\n\n\n\n\n\n\nTwo things to **note**:\n\n1.  The pipe symbol can be written as `|>` or `%>%`.\n    [^data-manipulation-2] To write it you may also use the `ctrl+shift+m` shortcut.\n\n2.  After typing `select(` you can press `tab` and the list of available variables of that dataset will show up! `Enter` to select. With this you prevent typo errors.\n\n[^data-manipulation-2]: You can change this in RStudio \\> Tools \\> Global Options \\> Code.\n\n## Filter observations\n\nYou can filter observations based on a condition using the `filter()` function.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRIPS2 = TRIPS[TRIPS$Total > 25000,] # using r-base, you cant forget the comma\nTRIPS2 = TRIPS2 |> filter(Total > 25000) # using dplyr, it's easier\n```\n:::\n\n\n\n\n\n\n\n\n\n\nYou can have other conditions inside the condition.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(TRIPS$Total)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n    361    5918   17474   22457   33378  112186 \n```\n\n\n:::\n\n```{.r .cell-code}\nTRIPS3 = TRIPS |> filter(Total > median(Total)) \n```\n:::\n\n\n\n\n\n\n\n\n\n\nOther filter conditions:\n\n-   `==` equal, `!=` different\n-   `<` smaller, `>` greater, `<=` smaller or equal, `>=` greater or equal\n-   `&` and, `|` or\n-   `is.na`, `!is.na` is not NA\n-   `%in%`, `!%in%` not in\n\n## Create new variables\n\nYou can also try again to create a variable of Car percentage using pipes!\nTo create a new variable or change an existing one (overwriting), you can use the `mutate()` function.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRIPS$Car_perc = TRIPS$Car/TRIPS$Total * 100 # using r-base\n\nTRIPS = TRIPS |> mutate(Car_perc = Car/Total * 100) # using dplyr\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Change data type\n\nData can be in different formats.\nFor example, the variable *Origin* is a character, but we can convert it to a numeric variable.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(TRIPS$Origin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nTRIPS = TRIPS |> \n  mutate(Origin_num = as.integer(Origin)) # you can use as.numeric() as well\nclass(TRIPS$Origin_num)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nMost used data types are:\n\n-   integer (`int`)\n-   numeric (`num`)\n-   character (`chr`)\n-   logical (`logical`)\n-   date (`Date`)\n-   factor (`factor`)\n\n### Factors\n\nFactors are useful to deal with categorical data.\nYou can convert a character to a factor using `as.factor()`, and also use labels and levels for categorical ordinal data.\n\nWe can change the `Lisbon` variable to a factor, and `Internal` too.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRIPS = TRIPS |> \n  mutate(Lisbon_factor = factor(Lisbon, labels = c(\"No\", \"Yes\")),\n         Internal_factor = factor(Internal, labels = c(\"Inter\", \"Intra\")))\n```\n:::\n\n\n\n\n\n\n\n\n\n\nBut how do we know which levels come first?\nA simple way is to use `table()` or `unique()` functions.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(TRIPS$Lisbon) # this will show all the different values\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 1\n```\n\n\n:::\n\n```{.r .cell-code}\ntable(TRIPS$Lisbon) # this will show the frequency of each value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n  0   1 \n188  48 \n```\n\n\n:::\n\n```{.r .cell-code}\ntable(TRIPS$Lisbon_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n No Yes \n188  48 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nThe first number to appear is the first level, and so on.\n\nYou can see the difference between using a continuous variable (in this case `Lisbon`\\` has 0 and 1) and a categorical variable (`Lisbon_factor`).\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(TRIPS$Lisbon) # the values range between 0 and 1\n```\n\n::: {.cell-output-display}\n![](data-manipulation_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(TRIPS$Lisbon_factor) # the values are categorical and labeled with Yes/No\n```\n\n::: {.cell-output-display}\n![](data-manipulation_files/figure-html/unnamed-chunk-15-2.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n## Join data tables\n\nWhen having relational tables - *i.e.* with a common identifier - it is useful to be able to join them in a very efficient way.\n\n`left_join` is a function that joins two tables **by a common column**.\nThe **first table is the one that will be kept**, and the **second one will be joined to** it.\nHow `left_join` works:\n\n[![A visual representation of the left join where every row in x appears in the output.Source: R for Data Science.](images/clipboard-1594422253.png){fig-align=\"center\" width=\"424\"}](https://r4ds.hadley.nz/joins#fig-join-left)\n\nLet's **join the municipalities** to this table with a supporting table that includes all the **relation** between neighbourhoods and municipalities, and the respective names and codes.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMunicipalities = readRDS(\"data/Municipalities_names.Rds\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(TRIPS)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 13\n  Origin Total  Walk  Bike   Car PTransit Other Internal Lisbon Car_perc\n  <chr>  <dbl> <dbl> <dbl> <dbl>    <dbl> <dbl>    <dbl>  <dbl>    <dbl>\n1 110501 35539 11325  1309 21446     1460     0        0      0     60.3\n2 110501 47602  3502   416 37727     5519   437        1      0     79.3\n3 110506 37183 12645    40 22379     2057    63        0      0     60.2\n4 110506 42313  1418   163 37337     3285   106        1      0     88.2\n5 110507 30725  9389  1481 19654      201     0        0      0     64.0\n6 110507 54586  2630   168 44611     6963   215        1      0     81.7\n# ℹ 3 more variables: Origin_num <int>, Lisbon_factor <fct>,\n#   Internal_factor <fct>\n```\n\n\n:::\n\n```{.r .cell-code}\ntail(Municipalities)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Mun_code Neighborhood_code        Municipality\n113     1109            110913               Mafra\n114     1114            111409 Vila Franca de Xira\n115     1109            110918               Mafra\n116     1109            110904               Mafra\n117     1502            150202           Alcochete\n118     1109            110911               Mafra\n                                             Neighborhood\n113                                         Santo Isidoro\n114                                   Vila Franca de Xira\n115 União das freguesias de Azueira e Sobral da Abelheira\n116                                            Encarnação\n117                                               Samouco\n118                                             Milharado\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nWe can see that we have a common variable: `Origin` in `TRIPS` and `Neighborhood_code` in `Municipalities`.\n\nTo join these two tables we need to specify the common variable in each table, using the `by` argument.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRIPSjoin = TRIPS |> left_join(Municipalities, by = c(\"Origin\" = \"Neighborhood_code\"))\n```\n:::\n\n\n\n\n\n\n\n\n\n\nIf you prefer, you can mutate or rename a variable so both tables have the same name.\nWhen **both tables have the same name**, you don't need to specify the `by` argument.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMunicipalities = Municipalities |> rename(Origin = \"Neighborhood_code\") # change name\nTRIPSjoin = TRIPS |> left_join(Municipalities) # automatic detects common variable\n```\n:::\n\n\n\n\n\n\n\n\n\n\nAs you can see, both tables don't need to be the same length.\nThe `left_join` function will keep all the observations from the first table, and join the second table to it.\nIf there is no match, the variables from the second table will be filled with `NA`.\n\n## group_by and summarize\n\nWe have a very large table with all the neighbourhoods and their respective municipalities.\nWe want to know the total number of trips with origin in each municipality.\n\nTo make it easier to understand, let's keep only the variables we need.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRIPSredux = TRIPSjoin |> select(Origin, Municipality, Internal, Car, Total)\nhead(TRIPSredux)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  Origin Municipality Internal   Car Total\n  <chr>  <chr>           <dbl> <dbl> <dbl>\n1 110501 Cascais             0 21446 35539\n2 110501 Cascais             1 37727 47602\n3 110506 Cascais             0 22379 37183\n4 110506 Cascais             1 37337 42313\n5 110507 Cascais             0 19654 30725\n6 110507 Cascais             1 44611 54586\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nWe can group this table by the `Municipality` variable and summarize the number of trips with origin in each municipality.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRIPSsum = TRIPSredux |> \n  group_by(Municipality) |> # you won't notice any chagne with only this\n  summarize(Total = sum(Total))\nhead(TRIPSsum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n  Municipality   Total\n  <chr>          <dbl>\n1 Alcochete      36789\n2 Almada        289834\n3 Amadora       344552\n4 Barreiro      133658\n5 Cascais       373579\n6 Lisboa       1365111\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nWe summed the total number of trips in each municipality.\n\nIf we want to group by more than one variable, we can add more `group_by()` functions.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRIPSsum2 = TRIPSredux |> \n  group_by(Municipality, Internal) |> \n  summarize(Total = sum(Total),\n            Car = sum(Car))\nhead(TRIPSsum2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n# Groups:   Municipality [3]\n  Municipality Internal  Total    Car\n  <chr>           <dbl>  <dbl>  <dbl>\n1 Alcochete           0  16954   9839\n2 Alcochete           1  19835  15632\n3 Almada              0 105841  49012\n4 Almada              1 183993 125091\n5 Amadora             0 117727  33818\n6 Amadora             1 226825 142386\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nWe summed the total number of trips and car trips in each municipality, **separated by** inter and intra municipal trips.\n\n::: {.callout-caution appearance=\"simple\"}\nIt is a good practice to use the `ungroup()` function after the `group_by()` function.\nThis will remove the grouping.\nIf you don't do this, the grouping will be kept and you may have unexpected results in the next time you use that dataset.\n:::\n\n## Arrange data\n\nYou can **sort** a dataset by one or more variables.\n\nFor instance, `arrange()` by Total trips, ascending or descending order.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRIPS2 = TRIPSsum2 |> arrange(Total)\nTRIPS2 = TRIPSsum2 |> arrange(-Total) # descending\n\nTRIPS2 = TRIPSsum2 |> arrange(Municipality) # alphabetic\n\nTRIPS4 = TRIPS |> arrange(Lisbon_factor, Total) # more than one variable\n```\n:::\n\n\n\n\n\n\n\n\n\n\nThis is not the same as opening the view table and click on the arrows.\nWhen you do that, the order is not saved in the dataset.\nIf you want to save the order, you need to use the `arrange()` function.\n\n## All together now!\n\nThis is the pipes magic.\nIt takes the last result and applies the next function to it.\n\"With this, do this.\".\nYou can chain as many functions as you want.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRIPS_pipes = TRIPS |> \n  select(Origin, Internal, Car, Total) |> \n  \n  mutate(Origin_num = as.integer(Origin)) |> \n  mutate(Internal_factor = factor(Internal, labels = c(\"Inter\", \"Intra\"))) |> \n  \n  filter(Internal_factor == \"Inter\")|>\n  \n  left_join(Municipalities) |>\n  \n  group_by(Municipality) |>\n  summarize(Total = sum(Total),\n            Car = sum(Car),\n            Car_perc = Car/Total * 100) |> \n  ungroup() |> \n  \n  arrange(desc(Car_perc))\n```\n:::\n\n\n\n\n\n\n\n\n\n\nWith this code we will have a table with the total number of intercity trips, by municipality, with their names instead of codes, arranged by the percentage of car trips.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRIPS_pipes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 18 × 4\n   Municipality         Total    Car Car_perc\n   <chr>                <dbl>  <dbl>    <dbl>\n 1 Mafra                65811  46329     70.4\n 2 Sesimbra             49370  31975     64.8\n 3 Cascais             161194  96523     59.9\n 4 Palmela              66428  39688     59.7\n 5 Alcochete            16954   9839     58.0\n 6 Setúbal             129059  70318     54.5\n 7 Montijo              57164  30900     54.1\n 8 Seixal              120747  63070     52.2\n 9 Sintra              237445 123408     52.0\n10 Oeiras              134862  66972     49.7\n11 Almada              105841  49012     46.3\n12 Loures              132310  60478     45.7\n13 Barreiro             52962  24160     45.6\n14 Odivelas             93709  39151     41.8\n15 Vila Franca de Xira 115152  47201     41.0\n16 Moita                51040  17394     34.1\n17 Amadora             117727  33818     28.7\n18 Lisboa              280079  69038     24.6\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n## Other dplyr functions\n\nYou can explore other `dplyr` functions and variations to manipulate data in the **dplyr cheat sheet**:\n\n[![](images/clipboard-2101323289.png)](https://rstudio.github.io/cheatsheets/data-transformation.pdf)\n\nTake a particular attention to `pivot_wider` and `pivot_longer` ([`tidyr`](https://tidyr.tidyverse.org/articles/pivot.html) package) to transform **OD matrices** in **wide** and **long** formats.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\nTable: OD matrix in long format\n\n|Origins |Destinations | Trips|\n|:-------|:------------|-----:|\n|A       |B            |    20|\n|A       |C            |    45|\n|B       |A            |    10|\n|C       |C            |     5|\n|C       |A            |    30|\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n\n\nTable: OD matrix in wide format\n\n|Trips |  A|  B|  C|\n|:-----|--:|--:|--:|\n|A     | NA| 20| 45|\n|B     | 10| NA| NA|\n|C     | 30| NA|  5|\n\n\n:::\n:::\n\n\n",
    "supporting": [
      "data-manipulation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}