---
title: "Buffers vs. Isochones"
code-fold: false
number-depth: 2
message: false
warning: false
format:
  pdf:
    prefer-html: true
---

We will use the `stplnar` package to create buffers in meters, and the `openrouteservice` package to create isochrones.

```{r setup, include=FALSE}
library(tidyverse)
library(sf)
library(stplanr) # to make buffers in meters
library(openrouteservice) # to make isochrones
library(mapview)
```

```{r}
#| include: false
# instructions to setup at the U-Shift server
options(openrouteservice.url = "https://ushift.rosafelix.bike/ors/") 
openrouteservice::ors_api_key("") # empty key
```

## Buffer

Represent a buffer of 500 m and 2000 m from IST[^3].

[^3]: Here I selected only the first variable because now we also have the coordinates information (unecessary for this procedure)

```{r bufferIST}
#| fig-format: png
#| message: false
IST = st_sfc(st_point(c(-9.1397404, 38.7370168)), crs = 4326) # create a point
IST$coordinates = st_coordinates(IST)

# BUFFERist500 = st_buffer(IST, dist = 500) # non  projected - results may be weird
BUFFERist500 = geo_buffer(IST[1], dist = 500) # from stplnar, to make sure it is in meters.
BUFFERist2000 = geo_buffer(IST[1], dist = 2000)

mapview(BUFFERist500) + mapview(BUFFERist2000, alpha.regions = 0.5)
```

## Isochrone

### Isochrone from 1 point - distance

We use again the `openrouteservice` r package.

```{r isoch1}
#| fig-format: png
#| message: false
ISOCist = ors_isochrones(
  IST$coordinates,
  profile = "foot-walking",
  range_type = "distance", # or time
  range = c(500, 1000, 2000),
  output = "sf"
)

ISOCist = arrange(ISOCist, -value) |>  # to make the larger polygons on top of the table so the are displayed behind.
          select(-center) # unnecessary variable

mapview(ISOCist, zcol = "value", alpha.regions = 0.5)
```

As you can see, the distance buffer of 500m is larger than the isochrone of 500m.
Actually we can measure their area of reach.

```{r arearatio}
ISOCist$area = st_area(ISOCist)
BUFFERist500$area = st_area(BUFFERist500)
BUFFERist2000$area = st_area(BUFFERist2000)

ratio1 = BUFFERist500$area / ISOCist$area[ISOCist$value == 500] # 1.71
ratio2 = BUFFERist2000$area / ISOCist$area[ISOCist$value == 2000] # 1.22
```

The euclidean buffer of 500m is `r round(ratio1, 2)` times larger than its isochrone, and the buffer of 2000m is `r round(ratio2, 2)` times larger than its isochrone.

### Isochrone from more than 1 point - time

For this purpose we will use the high schools dataset.

```{r getschools}
# import schools
SCHOOLS = st_read("../geo/SCHOOLS_basicsec.gpkg", quiet = TRUE)

SCHOOLS$coordinates = st_coordinates(SCHOOLS) # create coordinate variable

SCHOOLShigh = SCHOOLS |>
  filter(Nivel == "Secundario")  # filter the high schools
SCHOOLShigh = SCHOOLShigh |> mutate(id = 1:nrow(SCHOOLShigh)) # provide and id

# list of XY coordinates for ORS
coord_schools = data.frame(lon = SCHOOLShigh$coordinates[, 1],
                           lat = SCHOOLShigh$coordinates[, 2])
                           # id = SCHOOLShigh$id)
```

And proceed with the time isochrones, for a range of 20 min, with 5 min intervals.

```{r isoch2, include=TRUE}
ISOCschools = ors_isochrones(
  coord_schools,
  profile = "foot-walking",
  range_type = "time", # or distance
  range = 20*60, # 20 minutes in seconds
  interval = 5*60, # to have intervals of 5 minutes
  attributes = "area", #you can directly get area, population, and so on.
  output = "sf"
)

ISOCschools = arrange(ISOCschools, -value) |> # larger polygons on top of the table so the are displayed behind.
  select(-center)
```

<!-- Because `openrouteservece` only allows a [max of 5 requests](https://openrouteservice.org/restrictions/) for isochrones at a time, we put it in a loop to run for all the 19 high schools. -->

```{r isoch2loop, cache=TRUE}
#| eval: false
#| include: false

# WITH ORS IN USHIFT THIS IS NOT RELEVANT ANYMORE
ISOCist = data.frame() # to start with a skeleton of df

for (i in 1:nrow(coor)) {
  ISOCist_i =
    ors_isochrones(
      coor[i,],
      profile = "foot-walking",
      range_type = "time", # or distance
      range = 20 * 60, # 20 minutes in seconds
      interval = 5 * 60, # to have intervals of 5 minutes
      attributes = "area", #you can directly get area, population, and so on. see documentation
      output = "sf"
    )
  ISOCist = rbind(ISOCist, ISOCist_i) # bind the results into the skeleton, one by one
}
```

And now merge this information with the schools' names.

```{r}
ISOCschools = ISOCschools |>
  mutate(id = group_index + 1, # because group_index starts at 0
         value = value/60) |> 
    left_join(SCHOOLShigh |>
                st_drop_geometry() |>
                select(id, INF_NOME, Alunos))
```

```{r isoch2map}
#| fig-format: png
#| message: false
mapview(ISOCschools, zcol = "value", alpha.regions = 0.5)
```

And estimate areas for the 20min isochrones

```{r}
summary(ISOCschools$area[ISOCschools$value==20])/1000000 # in kmÂ²
```
